[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TruckerWeather",
    "section": "",
    "text": "Connects to a dockerized mssql database.# Set up the connection\nmssql_con &lt;- dbConnect(\n  odbc::odbc(),\n  driver = \"ODBC Driver 18 for SQL Server\", \n  server = \"localhost,1433\",               \n  database = \"TestDB\",                    \n  uid = \"sa\",                             \n  pwd = \"MyStr@ngPassw0rd11\",             \n  TrustServerCertificate = \"yes\"\n)\n\n# Test the connection\n#dbListTables(con)  # List tables in the database to verify the connection\n\n\n\n\n\nEstablish a DuckDB, embedded database connection.duckdb_con &lt;- dbConnect(duckdb::duckdb(\n     config = list(max_memory = '24GB')), \":memory:\")"
  },
  {
    "objectID": "index.html#database-connections",
    "href": "index.html#database-connections",
    "title": "TruckerWeather",
    "section": "",
    "text": "Connects to a dockerized mssql database.# Set up the connection\nmssql_con &lt;- dbConnect(\n  odbc::odbc(),\n  driver = \"ODBC Driver 18 for SQL Server\", \n  server = \"localhost,1433\",               \n  database = \"TestDB\",                    \n  uid = \"sa\",                             \n  pwd = \"MyStr@ngPassw0rd11\",             \n  TrustServerCertificate = \"yes\"\n)\n\n# Test the connection\n#dbListTables(con)  # List tables in the database to verify the connection\n\n\n\n\n\nEstablish a DuckDB, embedded database connection.duckdb_con &lt;- dbConnect(duckdb::duckdb(\n     config = list(max_memory = '24GB')), \":memory:\")"
  },
  {
    "objectID": "index.html#custom-output-tools",
    "href": "index.html#custom-output-tools",
    "title": "TruckerWeather",
    "section": "Custom Output Tools",
    "text": "Custom Output Tools\nTables\n\n\nTable formatting code.# Table theming script\n\neval_palette &lt;- function(pal_name, n = 10, pal_type, direction = NULL) {\n     if (pal_type == \"c\") {\n          return(paletteer_c(pal_name, n, direction))\n     } else if (pal_type == \"d\") {\n          return(paletteer_d(pal_name, n, direction))\n     } else if (pal_type == \"dynamic\") {\n          return(paletteer_dynamic(pal_name, n, direction))\n     }\n}\n\nr_table_theming &lt;- function(r_df,\n                            title,\n                            subtitle,\n                            footnotes_df,\n                            source_note,\n                            pal_df,\n                            multiline_feet = NULL,\n                            tbl_font_size = NULL,\n                            color_by_columns = NULL,\n                            row_name_col = NULL,\n                            do_col_labels = FALSE,\n                            target_everything = FALSE\n) {\n     if(is.null(row_name_col)) {\n          r_table &lt;- gt(r_df)\n          \n     } else{\n          r_table &lt;- gt(r_df,\n                        rowname_col = row_name_col,\n                       )\n     }\n     \n     r_table &lt;- r_table |&gt;\n          tab_header(title = title, subtitle = subtitle)\n     \n     if (nrow(r_df) &gt; 1 && target_everything == FALSE) {\n          # Formatted rows are added to the accumulator, \n          # building up to the final result\n          r_table &lt;- seq_len(nrow(pal_df)) |&gt;\n               reduce(\\(acc, i) {\n                    data_color(acc,\n                               palette = pal_df$pals[[i]],\n                               columns = pal_df$cols[[i]])\n               }, .init = r_table)\n     }\n     else if (nrow(r_df) &gt; 1 && target_everything == TRUE) {\n          # Formatted columns are added to the accumulator, \n          # building up to the final result\n          r_table &lt;- seq_len(nrow(pal_df)) |&gt;\n               reduce(\\(acc, i) {\n                    data_color(\n                         acc,\n                         columns = color_by_columns,\n                         palette = pal_df$pals[[i]],\n                         target_columns = everything()\n                    )\n               }, .init = r_table)\n     }\n     \n     # Footnotes are added to the accumulator, building up to the final result\n     r_table &lt;- seq_len(nrow(footnotes_df)) |&gt;\n          reduce(\\(acc, i) {\n               tab_footnote(\n                    acc,\n                    footnote = footnotes_df$notes[[i]],\n                    location = cells_column_labels(\n                         columns = footnotes_df$locations[[i]]),\n                    placement = \"auto\"\n               )\n          }, .init = r_table)\n     \n     if (ncol(r_df) &gt; 1 && do_col_labels == TRUE) {\n          cell_col_fills = pal_df$pals[[1]]\n          # Formatted column labels are added to the accumulator, \n          # building up to the final result\n          r_table &lt;- seq_len(nrow(pal_df)) |&gt;\n               reduce(\\(acc, i) {\n                    tab_style(\n                         acc,\n                         style = cell_fill(color = cell_col_fills[i]),\n                         locations = cells_column_labels(\n                              columns = pal_df$cols[[i]])\n                    )\n               }, .init = r_table)\n     }\n     \n     r_table &lt;- r_table |&gt;\n          tab_source_note(source_note = source_note)\n     \n     r_table &lt;- r_table |&gt;\n          tab_options(\n               column_labels.padding = px(10),\n               column_labels.font.weight = \"bold\",\n               column_labels.background.color = '#333',\n               column_labels.border.top.width = px(0),\n               column_labels.border.bottom.color = 'black',\n               column_labels.vlines.width = px(1),\n               column_labels.border.lr.width = px(1),\n               column_labels.border.bottom.width = px(0),\n               column_labels.border.lr.color = 'black',\n               column_labels.vlines.color = 'black',\n               footnotes.padding = px(5),\n               footnotes.background.color = '#222',\n               footnotes.sep = \", \",\n               footnotes.multiline = multiline_feet,\n               heading.padding = px(10),\n               heading.background.color = '#222',\n               heading.title.font.size = pct(125),\n               heading.subtitle.font.size = pct(110),\n               heading.border.bottom.width = px(0),\n               row.striping.include_table_body = TRUE,\n               row.striping.include_stub = TRUE,\n               row.striping.background_color = '#333',\n               row_group.as_column = TRUE,\n               source_notes.background.color = '#222',\n               stub.border.width = px(0),\n               stub.font.weight = \"bolder\",\n               table.margin.left = px(1),\n               table.margin.right = px(1),\n               table.align = \"center\",\n               table.border.top.width = px(0),\n               table.border.bottom.width = px(0),\n               table.background.color = '#222',\n               table.font.size = tbl_font_size,\n               table.layout = \"auto\",\n               table_body.hlines.color = 'black',\n               table_body.hlines.width = px(0),\n               table_body.vlines.width = px(0),\n               table_body.border.bottom.color = 'black',\n               table_body.border.top.color = 'black',\n               table_body.border.bottom.width = px(0),\n               table_body.border.top.width = px(0)\n          )\n     \n     \n \n     \n     \n     return(r_table)\n}\n\n\n\nPlots\n\n\nPlot theming code.###----  Plot output script\n\n# normal axes\nggplot_theming &lt;- function(...) {\n     theme_minimal() +\n          theme(\n               axis.title = element_text(\n                    color = 'gray100',\n                    margin = margin(10, 10, 10, 10, \"pt\")\n               ),\n               axis.title.x = element_text(margin = margin(10, 10, 10, 10, \"pt\"), face = \"bold\"),\n               axis.title.y = element_text(\n                    face = \"bold\",\n                    size = rel(1),\n                    margin = margin(10, 10, 10, 10, \"pt\")\n               ),\n               axis.text = element_text(color = 'gray', margin = margin(5, 5, 5, 5, \"pt\")),\n               axis.text.x = element_text(),\n               axis.text.y = element_text(margin = margin(0, 5, 0, 5, \"pt\")),\n               axis.text.x.top = element_text(vjust = 0.5),\n               legend.background = element_rect(fill = '#222'),\n               legend.position = \"bottom\",\n               legend.text = element_text(color = 'gray'),\n               legend.title = element_text(color = 'white'),\n               panel.background = element_rect(fill = '#222'),\n               panel.grid.major.x = element_line(linetype = 'solid', color = 'black'),\n               panel.grid.minor.x = element_line(linetype = \"dotted\", color = 'black'),\n               panel.grid.major.y = element_line(\n                    linetype = 'solid',\n                    color = 'black',\n                    linewidth = .2\n               ),\n               panel.grid.minor.y = element_line(linetype = 'dotted', color = 'black'),\n               plot.title = element_text(\n                    face = \"bold\",\n                    color = 'white',\n                    size = rel(1.5)\n               ),\n               plot.background = element_rect(fill = '#222'),\n               plot.caption = element_text(\n                    size = 10,\n                    color = \"gray80\",\n                    margin = margin(5, 2, 5, 2),\n                    hjust = 0\n               ),\n               #plot.margin = margin(0, 0, 0, 0, \"pt\"),\n               strip.text.y = element_text(color = \"gray\"),\n               strip.text.x = element_text(color = \"gray\", face = \"bold\"),\n               text = element_text(size = 12)\n          )\n}\n\n# flipped axes\nggplot_theming_flipped_axes &lt;- function(...) {\n     theme_minimal() +\n          theme(\n               axis.title = element_text(color = 'gray100'),\n               axis.text = element_text(color = 'gray'),\n               panel.background = element_rect(fill = '#222'),\n               panel.grid.major.x = element_line(linetype = 'dashed'),\n               panel.grid.minor.x = element_line(linetype = \"dotted\"),\n               panel.grid.major.y = element_line(linetype = 'solid'),\n               panel.grid.minor.y = element_line(linetype = 'dotted'),\n               plot.title = element_text(color = 'white', size = rel(2)),\n               plot.background = element_rect(fill = '#222'),\n               legend.background = element_rect(fill = '#222'),\n               legend.text = element_text(color = 'gray'),\n               legend.title = element_text(color = 'white')\n          )\n}"
  },
  {
    "objectID": "index.html#weather-data-api-connection",
    "href": "index.html#weather-data-api-connection",
    "title": "TruckerWeather",
    "section": "Weather Data API Connection",
    "text": "Weather Data API Connection\n(“🌤️ Free Open-Source Weather API  Open-Meteo.com” n.d.)\n\n“🌤️ Free Open-Source Weather API  Open-Meteo.com.” n.d. Accessed February 8, 2025. https://open-meteo.com/.\nRealistic Coordinate Examples\n\nIntersection of Hwy 70 & 270 38.748, -90.439\nThe St. Louis Regional Freightway 38.627480, -90.189781\nPort of St. Louis 38.609215, -90.204275\nUSPS Office Kansas City International Airport, KC, MO 39.304413, -94.720711\nWalmart Distribution Center, 1100 Matlock Dr, Saint James, MO 65559-9026 38.002338, -91.634422\nKCS International Freight Gateway, MO, 3301 East 147th Street, Kansas City, MO 64147 38.84930037041913, -94.55499143307868\nImport Hourly Data\n\n\nRun the API script to import the dataset.\ndef import_api_hourly(latitude: float, longitude: float) -&gt; pd.DataFrame:\n     # Setup the Open-Meteo API client with cache and retry on error\n     cache_session = requests_cache.CachedSession('.cache', expire_after = 3600)\n     retry_session = retry(cache_session, retries = 5, backoff_factor = 0.2)\n     openmeteo = openmeteo_requests.Client(session = retry_session)\n     \n     # Make sure all required weather variables are listed here\n     # The order of variables in hourly or daily is important to assign them correctly below\n     url = \"https://api.open-meteo.com/v1/forecast\"\n     params = {\n        \"latitude\": latitude,\n        \"longitude\": longitude,\n        \"hourly\": \n             [\"temperature_2m\", \n             \"precipitation_probability\", \n             \"precipitation\", \n             \"rain\", \n             \"showers\", \n             \"snowfall\", \n             \"snow_depth\", \n             \"weather_code\", \n             \"visibility\", \n             \"wind_speed_10m\", \n             \"wind_direction_10m\"],\n        \"temperature_unit\": \"fahrenheit\",\n        \"wind_speed_unit\": \"mph\",\n        \"precipitation_unit\": \"inch\",\n        \"timezone\": \"America/Chicago\",\n        \"forecast_days\": 1,\n        \"past_hours\": 6,\n        \"forecast_hours\": 24,\n        \"models\": \"best_match\"\n     }\n     responses = openmeteo.weather_api(url, params=params)\n     \n     # Process first location. Add a for-loop for multiple locations or weather models\n     response = responses[0]\n     print(f\"Coordinates {response.Latitude()}°N {response.Longitude()}°E\")\n     print(f\"Elevation {response.Elevation()} m asl\")\n     print(f\"Timezone {response.Timezone()} {response.TimezoneAbbreviation()}\")\n     print(f\"Timezone difference to GMT+0 {response.UtcOffsetSeconds()} s\")\n     \n     # Process hourly data. The order of variables needs to be the same as requested.\n     hourly = response.Hourly()\n     hourly_temperature_2m = hourly.Variables(0).ValuesAsNumpy()\n     hourly_precipitation_probability = hourly.Variables(1).ValuesAsNumpy()\n     hourly_precipitation = hourly.Variables(2).ValuesAsNumpy()\n     hourly_rain = hourly.Variables(3).ValuesAsNumpy()\n     hourly_showers = hourly.Variables(4).ValuesAsNumpy()\n     hourly_snowfall = hourly.Variables(5).ValuesAsNumpy()\n     hourly_snow_depth = hourly.Variables(6).ValuesAsNumpy()\n     hourly_weather_code = hourly.Variables(7).ValuesAsNumpy()\n     hourly_visibility = hourly.Variables(8).ValuesAsNumpy()\n     hourly_wind_speed_10m = hourly.Variables(9).ValuesAsNumpy()\n     hourly_wind_direction_10m = hourly.Variables(10).ValuesAsNumpy()\n     \n     hourly_data = {\"date\": pd.date_range(\n        start = pd.to_datetime(hourly.Time(), unit = \"s\", utc = True),\n        end = pd.to_datetime(hourly.TimeEnd(), unit = \"s\", utc = True),\n        freq = pd.Timedelta(seconds = hourly.Interval()),\n        inclusive = \"left\"\n     )}\n     \n     hourly_data[\"temperature_2m\"] = hourly_temperature_2m\n     hourly_data[\"precipitation_probability\"] = hourly_precipitation_probability\n     hourly_data[\"precipitation\"] = hourly_precipitation\n     hourly_data[\"rain\"] = hourly_rain\n     hourly_data[\"showers\"] = hourly_showers\n     hourly_data[\"snowfall\"] = hourly_snowfall\n     hourly_data[\"snow_depth\"] = hourly_snow_depth\n     hourly_data[\"weather_code\"] = hourly_weather_code\n     hourly_data[\"visibility\"] = hourly_visibility\n     hourly_data[\"wind_speed_10m\"] = hourly_wind_speed_10m\n     hourly_data[\"wind_direction_10m\"] = hourly_wind_direction_10m\n     \n     return(pd.DataFrame(data = hourly_data))\n\n\n\n\n\nRegister hourly api results as a virtual table.duckdb_register(duckdb_con, \n                \"hourly\", \n                py$import_api_hourly(38.748, -90.439),\n                overwrite = TRUE)\n\nCoordinates 38.74498748779297°N -90.4433364868164°E\nElevation 175.0 m asl\nTimezone b'America/Chicago' b'GMT-6'\nTimezone difference to GMT+0 -21600 s"
  },
  {
    "objectID": "index.html#model-background-info",
    "href": "index.html#model-background-info",
    "title": "TruckerWeather",
    "section": "Model Background Info",
    "text": "Model Background Info\n\nThe study, published in the Weather and Forecasting journal, focuses on evaluating and improving the accuracy of weather prediction models, particularly for severe weather events. It examines the performance of high-resolution numerical weather prediction (NWP) models in forecasting convective storms, which are critical for predicting severe weather such as thunderstorms, hail, and tornadoes. The research highlights advancements in model resolution, data assimilation techniques, and the integration of observational data to enhance forecast precision. The findings emphasize the importance of these improvements for short-term (nowcasting) and medium-range forecasts, particularly in regions prone to severe weather, like the central United States (including Missouri). Dowell et al. (2022)\n\nDowell, David C., Curtis R. Alexander, Eric P. James, Stephen S. Weygandt, Stanley G. Benjamin, Geoffrey S. Manikin, Benjamin T. Blake, et al. 2022. “The High-Resolution Rapid Refresh (HRRR): An Hourly Updating Convection-Allowing Forecast Model. Part I: Motivation and System Description.” Weather and Forecasting 37 (8): 1371–95. https://doi.org/10.1175/WAF-D-21-0151.1.\n\n\n\ntable setup# Create the tibble\nforecast_models &lt;- tibble(\n     Model = c(\"GFS\", \"HRRR\"),\n     Developed_By = c(\n          \"NOAA (National Oceanic and Atmospheric Administration)\",\n          \"NOAA (specifically by the Earth System Research Laboratory)\"\n     ),\n     Scope = c(\n          \"Global\",\n          \"Regional (primarily focused on the contiguous United States)\"\n     ),\n     Resolution = c(\n          \"Lower resolution compared to HRRR (approximately 13 km as of recent updates)\",\n          \"High resolution (3 km)\"\n     ),\n     Forecast_Range = c(\"Up to 16 days\", \"Up to 18 hours\"),\n     Updates = c(\"Runs four times a day (00Z, 06Z, 12Z, 18Z)\", \"Runs every hour\"),\n     Applications = c(\n          \"Used for long-term weather forecasting, climate modeling, and global weather patterns.\",\n          \"Ideal for short-term, detailed weather forecasting, including severe weather events like thunderstorms, tornadoes, and localized precipitation.\"\n     )\n)\n\nlocations_list = colnames(forecast_models)\n\nnotes_list =  list(\n  \"Organization or entity responsible for developing the model.\",\n  \"Geographical coverage of the model (e.g., global or regional).\",\n  \"Spatial resolution of the model, indicating the level of detail in the forecasts.\",\n  \"Time period for which the model provides forecasts.\",\n  \"Frequency at which the model is updated with new data.\",\n  \"Primary uses and strengths of the model in weather forecasting.\",\n  \"Main distinctions between the models, highlighting their unique features and capabilities.\"\n  )\n\nfootnotes_df &lt;- tibble(\n  notes = notes_list, \n  locations = locations_list)\n\npal_df &lt;- tibble(\n  cols = locations_list\n#  pals = list(eval_palette(\"viridis::viridis\", 2, 'c', 1))\n)\n\nrTable &lt;- r_table_theming(\nforecast_models,\ntitle = \"Forecast Models: Attributes\",\nsubtitle = NULL,\nfootnotes_df,\nsource_note = md(\"**source**: \"),\npal_df,\nmultiline_feet = TRUE,\ntbl_font_size = pct(85),\ntarget_everything = TRUE,\nrow_name_col = \"Model\"\n)\n\n\n\n\n\n\nTable 1\n\n\n\n\n\n\n\nForecast Models: Attributes\n    \n\n\n      Developed_By1\n\n      Scope2\n\n      Resolution3\n\n      Forecast_Range4\n\n      Updates5\n\n      Applications6\n\n    \n\n\n\nGFS\nNOAA (National Oceanic and Atmospheric Administration)\nGlobal\nLower resolution compared to HRRR (approximately 13 km as of recent updates)\nUp to 16 days\nRuns four times a day (00Z, 06Z, 12Z, 18Z)\nUsed for long-term weather forecasting, climate modeling, and global weather patterns.\n\n\nHRRR\nNOAA (specifically by the Earth System Research Laboratory)\nRegional (primarily focused on the contiguous United States)\nHigh resolution (3 km)\nUp to 18 hours\nRuns every hour\nIdeal for short-term, detailed weather forecasting, including severe weather events like thunderstorms, tornadoes, and localized precipitation.\n\n\n\nsource:\n    \n\n\n\n1 Geographical coverage of the model (e.g., global or regional).\n    \n\n\n2 Spatial resolution of the model, indicating the level of detail in the forecasts.\n    \n\n\n3 Time period for which the model provides forecasts.\n    \n\n\n4 Frequency at which the model is updated with new data.\n    \n\n\n5 Primary uses and strengths of the model in weather forecasting.\n    \n\n\n6 Main distinctions between the models, highlighting their unique features and capabilities.\n    \n\n\n\n\n\n\n\n\n\n\ntable setupforecast_model_differences &lt;- tibble(\n\"Resolution\" = c(\n\"HRRR has a much higher resolution than GFS, making it more accurate for short-term, localized forecasts.\"\n),\n\"Forecast_Range\" = c(\"GFS provides forecasts for a much longer period compared to HRRR.\"),\n\"Update_Frequency\" =  c(\n\"HRRR updates more frequently, which is crucial for capturing rapidly changing weather conditions.\"\n)\n)\n\nlocations_list = colnames(forecast_model_differences)\n\nnotes_list =  list(\n  \"Spatial resolution of the model, indicating the level of detail in the forecasts.\",\n  \"Time period for which the model provides forecasts.\",\n  \"Frequency at which the model is updated with new data.\")\n\nfootnotes_df &lt;- tibble(\n  notes = notes_list, \n  locations = locations_list)\n\npal_df &lt;- tibble(\n  cols = locations_list\n#  pals = list(eval_palette(\"viridis::viridis\", 2, 'c', 1))\n)\n\nrTable &lt;- r_table_theming(\nforecast_model_differences,\ntitle = \"Forecast Models: Differences\",\nsubtitle = NULL,\nfootnotes_df,\nsource_note = md(\"**source**: Kaggle\"),\npal_df,\nmultiline_feet = TRUE,\ntbl_font_size = pct(85),\ntarget_everything = TRUE,\nrow_name_col = NULL\n)\n\n\n\n\n\n\nTable 2\n\n\n\n\n\n\n\nForecast Models: Differences\n    \n\nResolution1\n\n      Forecast_Range2\n\n      Update_Frequency3\n\n    \n\n\nHRRR has a much higher resolution than GFS, making it more accurate for short-term, localized forecasts.\nGFS provides forecasts for a much longer period compared to HRRR.\nHRRR updates more frequently, which is crucial for capturing rapidly changing weather conditions.\n\n\nsource: Kaggle\n    \n\n\n\n1 Spatial resolution of the model, indicating the level of detail in the forecasts.\n    \n\n\n2 Time period for which the model provides forecasts.\n    \n\n\n3 Frequency at which the model is updated with new data."
  },
  {
    "objectID": "index.html#weather-condition-analysis",
    "href": "index.html#weather-condition-analysis",
    "title": "TruckerWeather",
    "section": "Weather Condition Analysis",
    "text": "Weather Condition Analysis\n\n\nPlot load.# Load necessary libraries\nlibrary(DBI)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(paletteer)\nlibrary(openair)\nsource(\"./scripts/Output/Plots/plot_output.R\")\nsource(\"./scripts/Setup/Enum/create_enum_and_associate.R\")\n\n\n# Helper function to execute a query and return the result\nexecute_query &lt;- function(con, query) {\n     dbGetQuery(con, query)\n}\n\n# 1 Day Temperature Trend ----\nplot_temperature_trend &lt;- function(con, freezing_threshold = 32) {\n     query &lt;- \"\n    SELECT\n      temperature_2m,\n      strftime(date, '%H:%M:%S') AS time_only,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly;\n  \"\n     \n     data &lt;- execute_query(con, query)\n     \n     rPlot &lt;- ggplot(data, aes(x = common_date, y = temperature_2m)) +\n          geom_line(color = \"black\", size = 0.5) +\n          geom_hline(\n               yintercept = freezing_threshold,\n               linetype = \"dashed\",\n               color = \"lightblue\",\n               linewidth = 0.4\n          ) +\n          geom_ribbon(\n               aes(\n                    ymin = freezing_threshold,\n                    ymax = ifelse(\n                         temperature_2m &gt; freezing_threshold,\n                         temperature_2m,\n                         freezing_threshold\n                    )\n               ),\n               fill = \"green\",\n               alpha = 0.5,\n               na.rm = TRUE\n          ) +\n          geom_ribbon(\n               aes(\n                    ymin = ifelse(\n                         temperature_2m &lt; freezing_threshold,\n                         temperature_2m,\n                         freezing_threshold\n                    ),\n                    ymax = freezing_threshold\n               ),\n               fill = \"lightblue\",\n               alpha = 0.5,\n               na.rm = TRUE\n          ) +\n          labs(\n               title = \"Temperature Forecast\",\n               x = \"\",\n               y = \"° F\",\n               caption = \"Green fill indicates temperatures above freezing; light blue fill indicates below freezing.\"\n          ) +\n          scale_x_datetime(\n               labels = label_date(\"%l %p\"),\n               breaks = \"7 day\",\n               minor_breaks = \"1 hour\",\n               guide = guide_axis(n.dodge = 2)\n          ) +\n          facet_grid(. ~ day) +\n          ggplot_theming()\n     \n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggTemperature.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file\n     img &lt;- readPNG(plot_path)\n     # Display the image\n     grid::grid.raster(img)\n}\n\n# Precipitation and Probability ----\nplot_precipitation &lt;- function(con) {\n     query &lt;- \"\n    SELECT\n      precipitation_probability,\n      precipitation,\n      rain,\n      snowfall,\n      strftime(date, '%H:%M:%S') AS time_only,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly;\n  \"\n     \n     data &lt;- execute_query(con, query)\n     \n     scale_factor &lt;- max(data$precipitation_probability, na.rm = TRUE) / max(data$rain, data$snowfall, na.rm = TRUE)\n     \n     rPlot &lt;- ggplot(data, aes(x = as.POSIXct(common_date))) +\n          geom_area(\n               aes(y = precipitation_probability, fill = \"Precipitation Probability\"),\n               linewidth = 0.2\n          ) +\n          geom_line(\n               aes(y = rain * scale_factor, color = \"Rain (inches)\"),\n               size = 1,\n               linetype = \"dashed\"\n          ) +\n          geom_line(\n               aes(y = snowfall * scale_factor, color = \"Snowfall (inches)\"),\n               size = 1,\n               linetype = \"dotted\"\n          ) +\n          scale_y_continuous(\n               name = \"Precipitation Probability (%)\",\n               sec.axis = sec_axis( ~ . / ifelse(\n                    is.infinite(scale_factor), 1000, scale_factor\n               ), name = \"Rain / Snowfall (inches)\")\n          ) +\n          scale_x_datetime(\n               labels = scales::date_format(\"%H:%M\"),\n               breaks = \"6 hours\",\n               minor_breaks = \"2 hour\",\n               guide = guide_axis(n.dodge = 1)\n          ) +\n          scale_color_manual(\n               name = \"Weather Condition\",\n               values = c(\n                    \"Rain (inches)\" = \"skyblue\",\n                    \"Snowfall (inches)\" = \"snow\"\n               )\n          ) +\n          scale_fill_manual(name = \"Chance of %\",\n                            values = c(\"Precipitation Probability\" = \"gray20\")) +\n          labs(title = \"Precipitation Forecast\", x = \"Time of Day\", y = \"Precipitation Probability (%)\") +\n          facet_grid(~ day) +\n          ggplot_theming()\n     \n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggPrecipitation.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file\n     #readPNG(plot_path) |&gt;\n          # Display the image\n      #    grid::grid.raster()\n     \n     # Read the PNG file\n     img &lt;- readPNG(plot_path)\n     # Display the image\n     grid::grid.raster(img)\n     \n}\n\n# OpenAir Wind Rose ----\nplot_wind_rose &lt;- function(con) {\n     query &lt;- \"\n    SELECT\n      wind_speed_10m,\n      wind_direction_10m,\n      strftime(date, '%H:%M:%S') AS time_only,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly;\n  \"\n     \n     data &lt;- execute_query(con, query)\n     \n     windRose(\n          data,\n          ws = \"wind_speed_10m\",\n          wd = \"wind_direction_10m\",\n          breaks = 5,\n          paddle = TRUE,\n          cols = paletteer_d(\"ggsci::springfield_simpsons\", n = 3),\n          key.position = \"left\"\n     )\n     \n     \n}\n\n# ggplot Wind Rose ----\nplot_wind_rose_ggplot &lt;- function(con) {\n     query &lt;- \"\n    SELECT\n      wind_speed_10m,\n      wind_direction_10m,\n      strftime(date, '%H:%M:%S') AS time_only,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly;\n  \"\n     \n     data &lt;- execute_query(con, query)\n     \n     data &lt;- data |&gt;\n          mutate(speed_bin = cut(\n               wind_speed_10m,\n               breaks = c(0, 2, 4, 6, 8, 10, Inf),\n               labels = c(\"0-2\", \"2-4\", \"4-6\", \"6-8\", \"8-10\", \"10+\")\n          ))\n     \n     rPlot &lt;- ggplot(data, aes(x = wind_direction_10m, fill = speed_bin)) +\n          geom_histogram(binwidth = 10,\n                         color = \"black\",\n                         position = \"stack\") +\n          coord_polar(start = 2 * pi) +\n          scale_x_continuous(limits = c(0, 360),\n                             breaks = seq(0, 360, by = 45)) +\n          labs(\n               title = \"Wind Rose\",\n               x = \"Wind Direction (°)\",\n               y = \"Frequency\",\n               fill = \"Wind Speed (m/s)\"\n          ) +\n          ggplot_theming()\n     \n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggWindRose.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file\n     img &lt;- readPNG(plot_path)\n     # Display the image\n     grid::grid.raster(img)\n     \n}\n\n# Visibility geom_line ----\nplot_visibility_line &lt;- function(con) {\n     query &lt;- \"\n    SELECT\n      visibility,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly;\n  \"\n     \n     data &lt;- execute_query(con, query)\n     \n     rPlot &lt;- ggplot(data, aes(x = common_date, y = visibility / 10 ^ 3)) +\n          geom_line(color = \"white\", size = 0.5) +\n          geom_point(color = \"gray\", alpha = 1) +\n          labs(title = \"Visibility Map\", x = \"Date\", y = \"Visibility (km)\") +\n          scale_x_datetime(\n               labels = scales::date_format(\"%H:%M\"),\n               breaks = \"6 hours\",\n               minor_breaks = \"2 hour\",\n               guide = guide_axis(n.dodge = 1)\n          ) +\n          facet_grid(~ day) +\n          ggplot_theming()\n     \n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggVisibilityLine.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file\n     img &lt;- readPNG(plot_path)\n     # Display the image\n     grid::grid.raster(img)\n     \n}\n\n# Visibility Non-Categorical Heat ----\nplot_visibility_heat &lt;- function(con) {\n     query &lt;- \"\n    SELECT\n      visibility,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly;\n  \"\n     \n     data &lt;- execute_query(con, query)\n     \n     rPlot &lt;- ggplot(data, aes(\n          x = common_date,\n          y = day,\n          fill = visibility / 10 ^ 3\n     )) +\n          geom_tile() +\n          scale_fill_viridis_c(option = \"magma\") +\n          labs(\n               title = \"Visibility Line-Chart\",\n               x = \"Time of Day\",\n               y = \"Date\",\n               fill = \"Visibility (km)\"\n          ) +\n          scale_x_datetime(\n               labels = scales::date_format(\"%H:%M\"),\n               breaks = \"6 hours\",\n               minor_breaks = \"2 hour\",\n               guide = guide_axis(n.dodge = 1)\n          ) +\n          ggplot_theming()\n     \n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggVisibilityHeat.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file\n     img &lt;- readPNG(plot_path)\n     # Display the image\n     grid::grid.raster(img)\n     \n}\n\n# Visibility Categorical Heat ----\nplot_visibility_categorical_heat &lt;- function(con) {\n     query &lt;- \"\n    SELECT\n      visibility,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly;\n  \"\n     \n     data &lt;- execute_query(con, query)\n     \n     data &lt;- data |&gt;\n          mutate(\n               visibility_category = case_when(\n                    visibility &gt; 30 * 10 ^ 3 ~ \"Clearest (&gt;30 km)\",\n                    visibility &gt; 10 * 10 ^ 3 ~ \"Excellent (10-30 km)\",\n                    visibility &gt; 5 * 10 ^ 3 ~ \"Good (5-10 km)\",\n                    visibility &gt; 2 * 10 ^ 3 ~ \"Moderate (2-5 km)\",\n                    visibility &gt; 1 * 10 ^ 3 ~ \"Low (1-2 km)\",\n                    TRUE ~ \"Fog/Haze (&lt;1 km)\"\n               )\n          )\n     \n     rPlot &lt;- ggplot(data,\n                     aes(x = common_date, y = day, fill = visibility_category)) +\n          geom_tile() +\n          scale_fill_manual(\n               values = c(\n                    \"Clearest (&gt;30 km)\" = \"green\",\n                    \"Excellent (10-30 km)\" = \"darkgreen\",\n                    \"Good (5-10 km)\" = \"yellow\",\n                    \"Moderate (2-5 km)\" = \"orange\",\n                    \"Low (1-2 km)\" = \"red\",\n                    \"Fog/Haze (&lt;1 km)\" = \"purple\"\n               )\n          ) +\n          labs(\n               title = \"Visibility Category Map\",\n               x = \"Time of Day\",\n               y = \"Date\",\n               fill = \"Visibility Level\"\n          ) +\n          scale_x_datetime(\n               labels = scales::date_format(\"%H:%M\"),\n               breaks = \"6 hours\",\n               minor_breaks = \"2 hour\",\n               guide = guide_axis(n.dodge = 1)\n          ) +\n          ggplot_theming()\n     \n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggVisibilityCat.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file\n     img &lt;- readPNG(plot_path)\n     # Display the image\n     grid::grid.raster(img)\n     \n}\n\n# Weather Codes ----\nplot_weather_codes &lt;- function(con) {\n     codes &lt;- c(\n          '0',\n          '1',\n          '2',\n          '3',\n          '45',\n          '48',\n          '51',\n          '53',\n          '55',\n          '56',\n          '57',\n          '61',\n          '63',\n          '65',\n          '66',\n          '67',\n          '71',\n          '73',\n          '75',\n          '77',\n          '80',\n          '81',\n          '82',\n          '85',\n          '86',\n          '95',\n          '96',\n          '99'\n     )\n     descriptions &lt;- c(\n          'Clear sky',\n          'Mainly clear',\n          'Partly cloudy',\n          'Overcast',\n          'Fog',\n          'Depositing rime fog',\n          'Drizzle: light',\n          'Drizzle: moderate',\n          'Drizzle: dense',\n          'Freezing drizzle: light',\n          'Freezing drizzle: dense',\n          'Rain: slight',\n          'Rain: moderate',\n          'Rain: heavy',\n          'Freezing rain: light',\n          'Freezing rain: heavy',\n          'Snow fall: slight',\n          'Snow fall: moderate',\n          'Snow fall: heavy',\n          'Snow grains',\n          'Rain showers: slight',\n          'Rain showers: moderate',\n          'Rain showers: violent',\n          'Snow showers: slight',\n          'Snow showers: heavy',\n          'Thunderstorm: slight or moderate',\n          'Thunderstorm with slight hail',\n          'Thunderstorm with heavy hail'\n     )\n     \n     result &lt;- create_enum_and_associate(con, \"WeatherCode\", codes, descriptions)\n     \n     query &lt;- \"\n    SELECT\n      hr.weather_code::INTEGER::TEXT::WeatherCode AS weather_code,\n      wc.Description AS description,\n      strftime(hr.date, '%H:%M:%S') AS time_only,\n      strftime(hr.date, '%b %d') AS day\n    FROM\n      hourly hr\n    LEFT JOIN WeatherCode wc ON wc.Code == hr.weather_code;\n  \"\n     \n     data &lt;- execute_query(con, query)\n     \n     data$time_only &lt;- as.POSIXct(data$time_only, format = \"%H:%M:%S\")\n     \n     rPlot &lt;- ggplot(data, aes(x = day, y = time_only, fill = description)) +\n          geom_tile(alpha = 0.3) +\n          scale_fill_paletteer_d(\"khroma::highcontrast\") +\n          scale_y_datetime(\n               date_labels = \"%H:%M\",\n               date_breaks = \"2 hours\",\n               sec.axis = dup_axis(name = \"\")\n          ) +\n          labs(\n               title = \"Weather Code Map\",\n               x = \"Day\",\n               y = \"Time of Day\",\n               fill = \"Weather Code\"\n          ) +\n          ggplot_theming()\n     \n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggWeatherCodes.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file\n     img &lt;- readPNG(plot_path)\n     # Display the image\n     grid::grid.raster(img)\n     \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Weather Codes\n\n\n\n\n\n\n\n\n\n\n\n(b) Freezing/Non-Freezing Temperature\n\n\n\n\n\n\n\n\n\n\n\n(c) Visibility (km)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Visibility Categories\n\n\n\n\n\n\n\n\n\n\n\n(e) Precipitation (empty if no precipitation)\n\n\n\n\n\n\n\n\n\n\n\n(f) Wind Rose\n\n\n\n\n\n\n\nFigure 1: These are the grouped figures.\n\n\nFigure 1\nFigure 1 (a)\nFigure 1 (b)\nFigure 1 (c)\nFigure 1 (d)\nFigure 1 (e)\nFigure 1 (f)"
  },
  {
    "objectID": "index.html#disconnect-from-databases",
    "href": "index.html#disconnect-from-databases",
    "title": "TruckerWeather",
    "section": "Disconnect From Databases",
    "text": "Disconnect From Databases\n\n\nDereference memory from the in-memory database connections.#dbDisconnect(mssql_con)\ndbDisconnect(duckdb_con)"
  }
]