[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Weather Assistant",
    "section": "",
    "text": "Currently optional: Connects to a dockerized mssql database.# Set up the connection\nmssql_con &lt;- dbConnect(\n  odbc::odbc(),\n  driver = \"ODBC Driver 18 for SQL Server\", \n  server = \"localhost,1433\",               \n  database = \"TestDB\",                    \n  uid = \"sa\",                             \n  pwd = \"MyStr@ngPassw0rd11\",             \n  TrustServerCertificate = \"yes\"\n)\n\n\n\n\n\n\nEstablish a DuckDB, embedded database connection.duckdb_con &lt;- dbConnect(duckdb::duckdb(\n     config = list(max_memory = '24GB')), \":memory:\")"
  },
  {
    "objectID": "index.html#database-connections",
    "href": "index.html#database-connections",
    "title": "Weather Assistant",
    "section": "",
    "text": "Currently optional: Connects to a dockerized mssql database.# Set up the connection\nmssql_con &lt;- dbConnect(\n  odbc::odbc(),\n  driver = \"ODBC Driver 18 for SQL Server\", \n  server = \"localhost,1433\",               \n  database = \"TestDB\",                    \n  uid = \"sa\",                             \n  pwd = \"MyStr@ngPassw0rd11\",             \n  TrustServerCertificate = \"yes\"\n)\n\n\n\n\n\n\nEstablish a DuckDB, embedded database connection.duckdb_con &lt;- dbConnect(duckdb::duckdb(\n     config = list(max_memory = '24GB')), \":memory:\")"
  },
  {
    "objectID": "index.html#custom-output-tools",
    "href": "index.html#custom-output-tools",
    "title": "Weather Assistant",
    "section": "Custom Output Tools",
    "text": "Custom Output Tools\nTables\n\n\ntable building and theming# Table Theming Script ----\n#' @description\n#' This script provides functions to create and theme tables using the `gt` package.\n#' It includes options for customizing colors, footnotes, and other stylistic elements.\n#' \n# eval_palette ----\n#' @description\n#' A helper function to evaluate color palettes using the `paletteer` package.\n#' @param pal_name The name of the palette to evaluate.\n#' @param n The number of colors to generate (default is 10).\n#' @param pal_type The type of palette (\"c\" for continuous, \"d\" for discrete, or \"dynamic\" for dynamic palettes).\n#' @param direction The direction of the palette (e.g., 1 for normal, -1 for reversed).\n#' \n#' @return A vector of colors corresponding to the specified palette.\n#' \n#' @example\n#' \\dontrun{\n#' colors &lt;- eval_palette(\"ggsci::springfield_simpsons\", n = 5, pal_type = \"d\")\n#' }\n#' @export \neval_palette &lt;- function(pal_name, n = 10, pal_type, direction = NULL) {\n     if (pal_type == \"c\") {\n          return(paletteer_c(pal_name, n, direction))\n     } else if (pal_type == \"d\") {\n          return(paletteer_d(pal_name, n, direction))\n     } else if (pal_type == \"dynamic\") {\n          return(paletteer_dynamic(pal_name, n, direction))\n     }\n}\n\n# r_table_theming ----\n#' @description\n#' The main function to create and theme a table using the `gt` package.\n#' @details\n#' **Color Coding** Applies color palettes to specific columns or the entire table.\n#' **Footnotes** Adds footnotes to specific columns or locations in the table.\n#' **Column Labels** Customizes the appearance of column labels, including background colors.\n#' **Table Styling** Applies various styling options, such as borders, padding, and font weights.\n#' **Shadow Effects** Optionally adds shadow effects to table body cells.\n#'\n#' @param r_df The data frame to be converted into a table.\n#' @param title The title of the table.\n#' @param subtitle The subtitle of the table.\n#' @param footnotes_df A data frame containing footnotes and their locations.\n#' @param source_note A source note to be added at the bottom of the table.\n#' @param pal_df A data frame containing color palettes and columns to apply them to.\n#' @param multiline_feet Whether footnotes should be multiline (default is NULL).\n#' @param tbl_font_size The font size of the table (default is NULL).\n#' @param color_by_columns Columns to apply color to (default is NULL).\n#' @param row_name_col The column to use as row names (default is NULL).\n#' @param do_col_labels Whether to apply custom styling to column labels (default is FALSE).\n#' @param target_everything Whether to apply color to all columns (default is FALSE).\n#' @param doBodyShadows Whether to apply shadow effects to table body cells (default is FALSE).\n#'\n#' @return A themed `gt` table object.\n#' \n#' @example \n#' \\dontrun{\n#'   data &lt;- data.frame(\n#'     Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n#'     Score = c(85, 92, 78)\n#'   )\n#'   pal_df &lt;- data.frame(\n#'     cols = list(\"Score\"),\n#'     pals = list(eval_palette(\"ggsci::springfield_simpsons\", n = 3, pal_type = \"d\"))\n#'   )\n#'   footnotes_df &lt;- data.frame(\n#'     notes = list(\"High score\"),\n#'     locations = list(\"Score\")\n#'   )\n#'   themed_table &lt;- r_table_theming(\n#'     r_df = data,\n#'     title = \"Student Scores\",\n#'     subtitle = \"Fall 2023\",\n#'     footnotes_df = footnotes_df,\n#'     source_note = \"Source: School Records\",\n#'     pal_df = pal_df,\n#'     do_col_labels = TRUE\n#'   )\n#'   themed_table\n#'  }\n#'  \n# r_table_theming ----\n# Main function to create and theme a table using the `gt` package.\n#' @export\nr_table_theming &lt;- function(r_df,\n                            title,\n                            subtitle,\n                            footnotes_df,\n                            source_note,\n                            pal_df,\n                            multiline_feet = NULL,\n                            tbl_font_size = NULL,\n                            color_by_columns = NULL,\n                            row_name_col = NULL,\n                            do_col_labels = FALSE,\n                            target_everything = FALSE,\n                            doBodyShadows = FALSE\n) {\n     # Initialize the gt table\n     if(is.null(row_name_col)) {\n          # If no row name column is specified, create a basic gt table\n          r_table &lt;- gt(r_df)\n     } else {\n          # If a row name column is specified, use it as the row names in the table\n          r_table &lt;- gt(r_df, rowname_col = row_name_col)\n     }\n     \n     # Apply color coding to specific columns or the entire table\n     if (nrow(r_df) &gt; 1 && target_everything == FALSE) {\n          # Apply color palettes to specific columns defined in pal_df\n          r_table &lt;- seq_len(nrow(pal_df)) |&gt;\n               reduce(\\(acc, i) {\n                    data_color(acc,\n                               columns = pal_df$cols[[i]],  # Apply color to specified columns\n                               palette = pal_df$pals[[i]]   # Use the specified palette\n                    )\n               }, .init = r_table)  # Start with the initial table and accumulate changes\n     }\n     else if (nrow(r_df) &gt; 1 && target_everything == TRUE) {\n          # Apply color palettes to all columns\n          r_table &lt;- seq_len(nrow(pal_df)) |&gt;\n               reduce(\\(acc, i) {\n                    data_color(\n                         acc,\n                         columns = color_by_columns,  # Apply color to specified columns\n                         palette = pal_df$pals[[i]],  # Use the specified palette\n                         target_columns = everything()  # Apply color to all columns\n                    )\n               }, .init = r_table)  # Start with the initial table and accumulate changes\n     }\n     \n     # Add footnotes to the table\n     r_table &lt;- seq_len(nrow(footnotes_df)) |&gt;\n          reduce(\\(acc, i) {\n               tab_footnote(\n                    acc,\n                    footnote = footnotes_df$notes[[i]],  # Add the footnote text\n                    location = cells_column_labels(\n                         columns = footnotes_df$locations[[i]]),  # Specify the column for the footnote\n                    placement = \"auto\"  # Automatically place the footnote\n               )\n          }, .init = r_table)  # Start with the initial table and accumulate changes\n     \n     # Apply custom styling to column labels (if enabled)\n     if (ncol(r_df) &gt; 1 && do_col_labels == TRUE) {\n          cell_col_fills = pal_df$pals[[1]]  # Get the first palette for column labels\n          # Apply background colors to column labels\n          r_table &lt;- seq_len(nrow(pal_df)) |&gt;\n               reduce(\\(acc, i) {\n                    tab_style(\n                         acc,\n                         style = cell_fill(color = cell_col_fills[i]),  # Fill column labels with color\n                         locations = cells_column_labels(\n                              columns = pal_df$cols[[i]])  # Apply to specified columns\n                    )\n               }, .init = r_table)  # Start with the initial table and accumulate changes\n     }\n     \n     # Add a title and subtitle to the table\n     r_table &lt;- r_table |&gt;\n          tab_header(title = title, subtitle = subtitle)\n     \n     # Add a source note at the bottom of the table\n     r_table &lt;- r_table |&gt;\n          tab_source_note(source_note = source_note)\n     \n     # Apply general table styling options\n     r_table &lt;- r_table |&gt;\n          tab_options(\n               column_labels.padding = px(10),  # Add padding to column labels\n               column_labels.font.weight = \"bold\",  # Make column labels bold\n               column_labels.background.color = '#333',  # Set background color for column labels\n               column_labels.border.top.width = px(0),  # Remove top border for column labels\n               column_labels.border.bottom.color = 'black',  # Set bottom border color for column labels\n               column_labels.vlines.width = px(1),  # Set vertical line width for column labels\n               column_labels.border.lr.width = px(1),  # Set left/right border width for column labels\n               column_labels.border.bottom.width = px(0),  # Remove bottom border for column labels\n               column_labels.border.lr.color = 'black',  # Set left/right border color for column labels\n               column_labels.vlines.color = 'black',  # Set vertical line color for column labels\n               footnotes.padding = px(5),  # Add padding to footnotes\n               footnotes.background.color = '#222',  # Set background color for footnotes\n               footnotes.sep = \", \",  # Set separator for footnotes\n               footnotes.multiline = multiline_feet,  # Allow multiline footnotes (if enabled)\n               heading.padding = px(10),  # Add padding to the heading\n               heading.background.color = '#222',  # Set background color for the heading\n               heading.title.font.size = pct(125),  # Set font size for the title\n               heading.subtitle.font.size = pct(110),  # Set font size for the subtitle\n               heading.border.bottom.width = px(0),  # Remove bottom border for the heading\n               row.striping.include_table_body = TRUE,  # Enable row striping for the table body\n               row.striping.include_stub = TRUE,  # Enable row striping for the stub\n               row.striping.background_color = '#333',  # Set background color for striped rows\n               row_group.as_column = TRUE,  # Display row groups as columns\n               source_notes.background.color = '#222',  # Set background color for source notes\n               stub.border.width = px(0),  # Remove border for the stub\n               stub.font.weight = \"bolder\",  # Make stub text bolder\n               table.margin.left = px(1),  # Set left margin for the table\n               table.margin.right = px(1),  # Set right margin for the table\n               table.align = \"center\",  # Center-align the table\n               table.border.top.width = px(0),  # Remove top border for the table\n               table.border.bottom.width = px(0),  # Remove bottom border for the table\n               table.background.color = '#222',  # Set background color for the table\n               table.font.size = tbl_font_size,  # Set font size for the table\n               table.layout = \"auto\",  # Use automatic table layout\n               table_body.hlines.color = 'black',  # Set horizontal line color for the table body\n               table_body.hlines.width = px(0),  # Remove horizontal lines in the table body\n               table_body.vlines.width = px(0),  # Remove vertical lines in the table body\n               table_body.border.bottom.color = 'black',  # Set bottom border color for the table body\n               table_body.border.top.color = 'black',  # Set top border color for the table body\n               table_body.border.bottom.width = px(0),  # Remove bottom border for the table body\n               table_body.border.top.width = px(0)  # Remove top border for the table body\n          )\n     \n     return(r_table)\n}\n\n\n\nPlots\n\n\nplot theming#  Plot output script ----\n# normal axes ----\nggplot_theming &lt;- function(...) {\n     theme_minimal() +\n          theme(\n               axis.title = element_text(\n                    color = 'gray100',\n                    margin = margin(10, 10, 10, 10, \"pt\")\n               ),\n               axis.title.x = element_text(margin = margin(10, 10, 10, 10, \"pt\"), face = \"bold\"),\n               axis.title.y = element_text(\n                    face = \"bold\",\n                    size = rel(1),\n                    margin = margin(10, 10, 10, 10, \"pt\")\n               ),\n               axis.text = element_text(color = 'gray', margin = margin(5, 5, 5, 5, \"pt\")),\n               axis.text.x = element_text(),\n               axis.text.y = element_text(margin = margin(0, 5, 0, 5, \"pt\")),\n               axis.text.x.top = element_text(vjust = 0.5),\n               legend.background = element_rect(fill = '#222'),\n               legend.position = \"bottom\",\n               legend.text = element_text(color = 'gray'),\n               legend.title = element_text(color = 'white'),\n               panel.background = element_rect(fill = '#222'),\n               panel.grid.major.x = element_line(linetype = 'solid', color = 'black'),\n               panel.grid.minor.x = element_line(linetype = \"dotted\", color = 'black'),\n               panel.grid.major.y = element_line(\n                    linetype = 'solid',\n                    color = 'black',\n                    linewidth = .2\n               ),\n               panel.grid.minor.y = element_line(linetype = 'dotted', color = 'black'),\n               plot.title = element_text(\n                    face = \"bold\",\n                    color = 'white',\n                    size = rel(1.5)\n               ),\n               plot.background = element_rect(fill = '#222'),\n               plot.caption = element_text(\n                    size = 10,\n                    color = \"gray80\",\n                    margin = margin(5, 2, 5, 2),\n                    hjust = 0\n               ),\n               #plot.margin = margin(0, 0, 0, 0, \"pt\"),\n               strip.text.y = element_text(color = \"gray\"),\n               strip.text.x = element_text(color = \"gray\", face = \"bold\"),\n               text = element_text(size = 12)\n          )\n}\n\n# flipped axes ----\nggplot_theming_flipped_axes &lt;- function(...) {\n     theme_minimal() +\n          theme(\n               axis.title = element_text(color = 'gray100'),\n               axis.text = element_text(color = 'gray'),\n               panel.background = element_rect(fill = '#222'),\n               panel.grid.major.x = element_line(linetype = 'dashed'),\n               panel.grid.minor.x = element_line(linetype = \"dotted\"),\n               panel.grid.major.y = element_line(linetype = 'solid'),\n               panel.grid.minor.y = element_line(linetype = 'dotted'),\n               plot.title = element_text(color = 'white', size = rel(2)),\n               plot.background = element_rect(fill = '#222'),\n               legend.background = element_rect(fill = '#222'),\n               legend.text = element_text(color = 'gray'),\n               legend.title = element_text(color = 'white')\n          )\n}\n\n\n\n\n\nplot building# Load necessary libraries\nlibrary(DBI)          # For database connectivity\nlibrary(ggplot2)      # For creating plots\nlibrary(scales)       # For scaling and formatting axes\nlibrary(openair)      # For specialized plots like wind roses\nsource(\"./scripts/Output/Plots/plot_themer.R\")  # Custom theme for ggplot\n\n# Helper function to execute a query and return the result\nexecute_query &lt;- function(con, query) {\n     dbGetQuery(con, query)  # Execute the SQL query and return the result\n}\n\n# 1 Day Temperature Trend ----\nplot_temperature_trend &lt;- function(con, freezing_threshold = 32) {\n     # Query to fetch temperature data for the day\n     query &lt;- \"\n    SELECT\n      temperature_2m,\n      strftime(date, '%H:%M:%S') AS time_only,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly_day_forecast;\n  \"\n     \n     data &lt;- execute_query(con, query)  # Execute the query and get the data\n     \n     # Create a ggplot object for temperature trend\n     rPlot &lt;- ggplot(data, aes(x = common_date, y = temperature_2m)) +\n          geom_line(color = \"black\", size = 0.5) +  # Line plot for temperature\n          geom_hline(\n               yintercept = freezing_threshold,\n               linetype = \"dashed\",\n               color = \"lightblue\",\n               linewidth = 0.4\n          ) +  # Horizontal line for freezing threshold\n          geom_ribbon(\n               aes(\n                    ymin = freezing_threshold,\n                    ymax = ifelse(\n                         temperature_2m &gt; freezing_threshold,\n                         temperature_2m,\n                         freezing_threshold\n                    ),\n                    fill = \"above freezing\"\n               ),\n               alpha = 0.5,\n               na.rm = TRUE\n          ) +  # Ribbon for temperatures above freezing\n          geom_ribbon(\n               aes(\n                    ymin = ifelse(\n                         temperature_2m &lt;= freezing_threshold,\n                         temperature_2m,\n                         freezing_threshold\n                    ),\n                    ymax = freezing_threshold,\n                    fill = \"at/below freezing\"\n               ),\n               alpha = 0.5,\n               na.rm = TRUE\n          ) +  # Ribbon for temperatures at/below freezing\n          labs(\n               title = \"Temperature Forecast\",\n               x = \"\",\n               y = \"¬∞ F\"\n          ) +  # Labels for the plot\n          scale_x_datetime(\n               labels = label_date(\"%l %p\"),\n               breaks = \"6 hours\",\n               minor_breaks = \"2 hours\",\n               guide = guide_axis(n.dodge = 1)\n          ) +  # Format x-axis for time\n          scale_y_continuous(sec.axis = dup_axis(name = \"\")) +  # Secondary y-axis\n          scale_fill_manual(\n               name = \"Freezing Indicators\",\n               values = c(\n                    \"above freezing\" = \"green\",\n                    \"below freezing\" = \"lightblue\"\n               )\n          ) +  # Manual color scale for freezing indicators\n          facet_grid(~ day) +  # Facet by day\n          ggplot_theming()  # Apply custom theme\n     \n     # Save the plot as a PNG file\n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggTemperature.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file and display it\n     img &lt;- readPNG(plot_path)\n     grid::grid.raster(img)\n}\n\n# Precipitation and Probability ----\nplot_precipitation &lt;- function(con) {\n     # Query to fetch precipitation data\n     query &lt;- \"\n    SELECT\n      precipitation_probability,\n      precipitation,\n      rain,\n      snowfall,\n      strftime(date, '%H:%M:%S') AS time_only,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly_day_forecast;\n  \"\n     \n     data &lt;- execute_query(con, query)  # Execute the query and get the data\n     \n     # Calculate scale factor for secondary y-axis\n     scale_factor &lt;- max(data$precipitation_probability, \n                         na.rm = TRUE) / max(data$rain, \n                                             data$snowfall, na.rm = TRUE)\n     \n     # Create a ggplot object for precipitation\n     rPlot &lt;- ggplot(data, aes(x = as.POSIXct(common_date))) +\n          geom_area(\n               aes(y = precipitation_probability, fill = \"Precipitation Probability\"),\n               linewidth = 0.2\n          ) +  # Area plot for precipitation probability\n          geom_line(\n               aes(y = rain * scale_factor, color = \"Rain (inches)\"),\n               size = 1,\n               linetype = \"dashed\"\n          ) +  # Line plot for rain\n          geom_line(\n               aes(y = snowfall * scale_factor, color = \"Snowfall (inches)\"),\n               size = 1,\n               linetype = \"dotted\"\n          ) +  # Line plot for snowfall\n          scale_y_continuous(\n               name = \"Precipitation Probability (%)\",\n               sec.axis = sec_axis( ~ . / ifelse(\n                    is.infinite(scale_factor), 1000, scale_factor\n               ), name = \"Rain / Snowfall (inches)\")\n          ) +  # Dual y-axes\n          scale_x_datetime(\n               labels = scales::date_format(\"%H:%M\"),\n               breaks = \"6 hours\",\n               minor_breaks = \"2 hour\",\n               guide = guide_axis(n.dodge = 1)\n          ) +  # Format x-axis for time\n          scale_color_manual(\n               name = \"Weather Condition\",\n               values = c(\n                    \"Rain (inches)\" = \"skyblue\",\n                    \"Snowfall (inches)\" = \"snow\"\n               )\n          ) +  # Manual color scale for weather conditions\n          scale_fill_manual(name = \"Chance of\",\n                            values = c(\"Precipitation Probability\" = \"gray20\")) +  # Fill color for precipitation probability\n          labs(title = \"Precipitation Forecast\", \n               x = \"Time of Day\", \n               y = \"Precipitation Probability (%)\") +  # Labels for the plot\n          facet_grid(~ day) +  # Facet by day\n          ggplot_theming()  # Apply custom theme\n     \n     # Save the plot as a PNG file\n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggPrecipitation.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file and display it\n     img &lt;- readPNG(plot_path)\n     grid::grid.raster(img)\n     \n}\n\n# OpenAir Wind Rose ----\nplot_wind_rose &lt;- function(con) {\n     # Query to fetch wind data\n     query &lt;- \"\n    SELECT\n      wind_speed_10m,\n      wind_direction_10m,\n      strftime(date, '%H:%M:%S') AS time_only,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly_day_forecast;\n  \"\n     \n     data &lt;- execute_query(con, query)  # Execute the query and get the data\n     \n     # Create a wind rose plot using the openair package\n     windRose(\n          data,\n          ws = \"wind_speed_10m\",\n          wd = \"wind_direction_10m\",\n          breaks = 5,\n          paddle = TRUE,\n          cols = paletteer_d(\"ggsci::springfield_simpsons\", n = 3),\n          key.position = \"left\"\n     )\n}\n\n# ggplot Wind Rose ----\nplot_wind_rose_ggplot &lt;- function(con) {\n     # Query to fetch wind data\n     query &lt;- \"\n    SELECT\n      wind_speed_10m,\n      wind_direction_10m,\n      strftime(date, '%H:%M:%S') AS time_only,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly_day_forecast;\n  \"\n     \n     data &lt;- execute_query(con, query)  # Execute the query and get the data\n     \n     # Bin wind speeds into categories\n     data &lt;- data |&gt;\n          mutate(speed_bin = cut(\n               wind_speed_10m,\n               breaks = c(0, 2, 4, 6, 8, 10, Inf),\n               labels = c(\"0-2\", \"2-4\", \"4-6\", \"6-8\", \"8-10\", \"10+\")\n          ))\n     \n     # Create a wind rose plot using ggplot\n     rPlot &lt;- ggplot(data, aes(x = wind_direction_10m, fill = speed_bin)) +\n          geom_histogram(binwidth = 10,\n                         color = \"black\",\n                         position = \"stack\") +  # Histogram for wind direction\n          coord_polar(start = 2 * pi) +  # Convert to polar coordinates\n          scale_x_continuous(limits = c(0, 360),\n                             breaks = seq(0, 360, by = 45)) +  # Format x-axis for degrees\n          labs(\n               title = \"Wind Rose\",\n               x = \"Wind Direction (¬∞)\",\n               y = \"Frequency\",\n               fill = \"Wind Speed (m/s)\"\n          ) +  # Labels for the plot\n          ggplot_theming()  # Apply custom theme\n     \n     # Save the plot as a PNG file\n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggWindRose.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file and display it\n     img &lt;- readPNG(plot_path)\n     grid::grid.raster(img)\n     \n}\n\n# Visibility geom_line ----\nplot_visibility_line &lt;- function(con) {\n     # Query to fetch visibility data\n     query &lt;- \"\n    SELECT\n      visibility,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly_day_forecast;\n  \"\n     \n     data &lt;- execute_query(con, query)  # Execute the query and get the data\n     \n     # Create a ggplot object for visibility trend\n     rPlot &lt;- ggplot(data, aes(x = common_date, y = visibility / 10 ^ 3)) +\n          geom_line(color = \"white\", size = 0.5) +  # Line plot for visibility\n          geom_point(color = \"gray\", alpha = 1) +  # Points for visibility\n          labs(title = \"Visibility Map\", x = \"Date\", y = \"Visibility (km)\") +  # Labels for the plot\n          scale_x_datetime(\n               labels = scales::date_format(\"%H:%M\"),\n               breaks = \"6 hours\",\n               minor_breaks = \"2 hour\",\n               guide = guide_axis(n.dodge = 1)\n          ) +  # Format x-axis for time\n          facet_grid(~ day) +  # Facet by day\n          ggplot_theming()  # Apply custom theme\n     \n     # Save the plot as a PNG file\n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggVisibilityLine.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file and display it\n     img &lt;- readPNG(plot_path)\n     grid::grid.raster(img)\n     \n}\n\n# Visibility Non-Categorical Heat ----\nplot_visibility_heat &lt;- function(con) {\n     # Query to fetch visibility data\n     query &lt;- \"\n    SELECT\n      visibility,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly_day_forecast;\n  \"\n     \n     data &lt;- execute_query(con, query)  # Execute the query and get the data\n     \n     # Create a ggplot object for visibility heatmap\n     rPlot &lt;- ggplot(data, aes(\n          x = common_date,\n          y = day,\n          fill = visibility / 10 ^ 3\n     )) +\n          geom_tile() +  # Tile plot for visibility\n          scale_fill_viridis_c(option = \"magma\") +  # Color scale for visibility\n          labs(\n               title = \"Visibility (km)\",\n               x = \"Time of Day\",\n               y = \"Date\",\n               fill = \"Visibility (km)\"\n          ) +  # Labels for the plot\n          scale_x_datetime(\n               labels = scales::date_format(\"%H:%M\"),\n               breaks = \"6 hours\",\n               minor_breaks = \"2 hour\",\n               guide = guide_axis(n.dodge = 1)\n          ) +  # Format x-axis for time\n          ggplot_theming()  # Apply custom theme\n     \n     # Save the plot as a PNG file\n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggVisibilityHeat.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file and display it\n     img &lt;- readPNG(plot_path)\n     grid::grid.raster(img)\n     \n}\n\n# Visibility Categorical Heat ----\nplot_visibility_categorical_heat &lt;- function(con) {\n     # Query to fetch visibility data\n     query &lt;- \"\n    SELECT\n      visibility,\n      strptime('1970-01-01 ' || strftime(date, '%H:%M:%S'), '%Y-%m-%d %H:%M:%S') AS common_date,\n      strftime(date, '%b %d') AS day\n    FROM\n      hourly_day_forecast;\n  \"\n     \n     data &lt;- execute_query(con, query)  # Execute the query and get the data\n     \n     # Categorize visibility into different levels\n     data &lt;- data |&gt;\n          mutate(\n               visibility_category = case_when(\n                    visibility &gt; 30 * 10 ^ 3 ~ \"Clearest (&gt;30 km)\",\n                    visibility &gt; 10 * 10 ^ 3 ~ \"Excellent (10-30 km)\",\n                    visibility &gt; 5 * 10 ^ 3 ~ \"Good (5-10 km)\",\n                    visibility &gt; 2 * 10 ^ 3 ~ \"Moderate (2-5 km)\",\n                    visibility &gt; 1 * 10 ^ 3 ~ \"Low (1-2 km)\",\n                    TRUE ~ \"Fog/Haze (&lt;1 km)\"\n               )\n          )\n     \n     # Create a ggplot object for categorical visibility heatmap\n     rPlot &lt;- ggplot(data,\n                     aes(x = common_date, y = day, fill = visibility_category)) +\n          geom_tile() +  # Tile plot for visibility categories\n          scale_fill_manual(\n               values = c(\n                    \"Clearest (&gt;30 km)\" = \"green\",\n                    \"Excellent (10-30 km)\" = \"darkgreen\",\n                    \"Good (5-10 km)\" = \"yellow\",\n                    \"Moderate (2-5 km)\" = \"orange\",\n                    \"Low (1-2 km)\" = \"red\",\n                    \"Fog/Haze (&lt;1 km)\" = \"purple\"\n               )\n          ) +  # Manual color scale for visibility categories\n          labs(\n               title = \"Visibility Category Map\",\n               x = \"Time of Day\",\n               y = \"Date\",\n               fill = \"Visibility Level\"\n          ) +  # Labels for the plot\n          scale_x_datetime(\n               labels = scales::date_format(\"%H:%M\"),\n               breaks = \"6 hours\",\n               minor_breaks = \"2 hour\",\n               guide = guide_axis(n.dodge = 1)\n          ) +  # Format x-axis for time\n          ggplot_theming()  # Apply custom theme\n     \n     # Save the plot as a PNG file\n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggVisibilityCat.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file and display it\n     img &lt;- readPNG(plot_path)\n     grid::grid.raster(img)\n}\n\n# Weather Codes ----\nplot_weather_codes &lt;- function(con) {\n     # Query to fetch weather codes and descriptions\n     query &lt;- \"\n    SELECT\n      hr.weather_code::INTEGER::TEXT::WeatherCode AS weather_code,\n      wc.Description AS description,\n      strftime(hr.date, '%H:%M:%S') AS time_only,\n      strftime(hr.date, '%b %d') AS day\n    FROM\n      hourly_day_forecast hr\n    LEFT JOIN WeatherCode wc ON wc.Code == hr.weather_code;\n  \"\n     \n     data &lt;- execute_query(con, query)  # Execute the query and get the data\n     \n     # Convert time_only to POSIXct for plotting\n     data$time_only &lt;- as.POSIXct(data$time_only, format = \"%H:%M:%S\")\n     \n     # Create a ggplot object for weather codes\n     rPlot &lt;- ggplot(data, aes(x = day, y = time_only, fill = description)) +\n          geom_tile(alpha = 0.3) +  # Tile plot for weather codes\n          scale_fill_paletteer_d(\"khroma::highcontrast\") +  # Color scale for weather codes\n          scale_y_datetime(\n               date_labels = \"%H:%M\",\n               date_breaks = \"2 hours\",\n               sec.axis = dup_axis(name = \"\")\n          ) +  # Format y-axis for time\n          labs(\n               title = \"Weather Code Map\",\n               x = \"Day\",\n               y = \"Time of Day\",\n               fill = \"Weather Code\"\n          ) +  # Labels for the plot\n          ggplot_theming()  # Apply custom theme\n     \n     # Save the plot as a PNG file\n     base_path &lt;- \"data/plots/\"\n     plot_path &lt;- paste0(base_path, \"ggWeatherCodes.png\")\n     ggsave(plot_path, plot = rPlot, scale = 1.5)\n     \n     # Read the PNG file and display it\n     img &lt;- readPNG(plot_path)\n     grid::grid.raster(img)\n     \n}"
  },
  {
    "objectID": "index.html#weather-data-api-connection",
    "href": "index.html#weather-data-api-connection",
    "title": "Weather Assistant",
    "section": "Weather Data API Connection",
    "text": "Weather Data API Connection\n(‚Äúüå§Ô∏è Free Open-Source Weather API  Open-Meteo.com‚Äù n.d.)\n\n‚Äúüå§Ô∏è Free Open-Source Weather API  Open-Meteo.com.‚Äù n.d. Accessed February 8, 2025. https://open-meteo.com/.\nImport Hourly Data\n\n\nRun the API script to import the dataset.import polars as pl  # For data manipulation and DataFrame creation\nimport pandas as pd  # For generating the date range\nimport requests_cache  # For caching API requests to reduce load and improve performance\nfrom retry_requests import retry  # For retrying failed API requests\nimport openmeteo_requests  # For interacting with the Open-Meteo API\nfrom datetime import datetime, timezone  # For handling date and time\n\ndef import_api_hourly(latitude: float, longitude: float) -&gt; pl.DataFrame:\n    \"\"\"\n    Fetches hourly weather data from the Open-Meteo API for the given latitude and longitude.\n\n    Parameters:\n        latitude (float): The latitude of the location for which weather data is requested.\n        longitude (float): The longitude of the location for which weather data is requested.\n\n    Returns:\n        pl.DataFrame: A Polars DataFrame containing hourly weather data for the specified location.\n    \"\"\"\n    \n    # Setup the Open-Meteo API client with cache and retry on error\n    # Caching reduces the number of API calls by storing responses for 1 hour (3600 seconds)\n    cache_session = requests_cache.CachedSession('.cache', expire_after = 3600)\n    \n    # Retry mechanism: retry up to 5 times with exponential backoff if the request fails\n    retry_session = retry(cache_session, retries = 5, backoff_factor = 0.2)\n    \n    # Initialize the Open-Meteo API client with the cached and retry-enabled session\n    openmeteo = openmeteo_requests.Client(session = retry_session)\n    \n    # Define the API endpoint and parameters for the weather data request\n    url = \"https://api.open-meteo.com/v1/forecast\"\n    params = {\n        \"latitude\": latitude,  # Latitude of the location\n        \"longitude\": longitude,  # Longitude of the location\n        \"hourly\": [  # List of hourly weather variables to fetch\n            \"temperature_2m\",  # Temperature at 2 meters above ground\n            \"precipitation_probability\",  # Probability of precipitation\n            \"precipitation\",  # Total precipitation\n            \"rain\",  # Rain amount\n            \"showers\",  # Showers amount\n            \"snowfall\",  # Snowfall amount\n            \"snow_depth\",  # Snow depth\n            \"weather_code\",  # Weather condition code\n            \"visibility\",  # Visibility\n            \"wind_speed_10m\",  # Wind speed at 10 meters above ground\n            \"wind_direction_10m\"  # Wind direction at 10 meters above ground\n        ],\n        \"temperature_unit\": \"fahrenheit\",  # Temperature unit (Fahrenheit)\n        \"wind_speed_unit\": \"mph\",  # Wind speed unit (miles per hour)\n        \"precipitation_unit\": \"inch\",  # Precipitation unit (inches)\n        \"timezone\": \"America/Chicago\",  # Timezone for the data\n        \"forecast_days\": 1,  # Number of forecast days (1 day)\n        \"past_hours\": 6,  # Include past 6 hours of data\n        \"forecast_hours\": 24,  # Include next 24 hours of forecast\n        \"models\": \"best_match\"  # Use the best matching weather model\n    }\n    \n    # Make the API request to fetch weather data\n    responses = openmeteo.weather_api(url, params = params)\n    \n    # Process the first location in the response (only one location is requested)\n    response = responses[0]\n    \n    # Print location and timezone information for debugging\n    print(f\"Coordinates {response.Latitude()}¬∞N {response.Longitude()}¬∞E\")\n    print(f\"Elevation {response.Elevation()} m asl\")\n    print(f\"Timezone {response.Timezone()} {response.TimezoneAbbreviation()}\")\n    print(f\"Timezone difference to GMT+0 {response.UtcOffsetSeconds()} s\")\n    \n    # Process hourly data from the API response\n    hourly = response.Hourly()\n    \n    # Extract each hourly weather variable from the response\n    hourly_temperature_2m = hourly.Variables(0).ValuesAsNumpy()  # Temperature at 2m\n    hourly_precipitation_probability = hourly.Variables(1).ValuesAsNumpy()  # Precipitation probability\n    hourly_precipitation = hourly.Variables(2).ValuesAsNumpy()  # Total precipitation\n    hourly_rain = hourly.Variables(3).ValuesAsNumpy()  # Rain amount\n    hourly_showers = hourly.Variables(4).ValuesAsNumpy()  # Showers amount\n    hourly_snowfall = hourly.Variables(5).ValuesAsNumpy()  # Snowfall amount\n    hourly_snow_depth = hourly.Variables(6).ValuesAsNumpy()  # Snow depth\n    hourly_weather_code = hourly.Variables(7).ValuesAsNumpy()  # Weather condition code\n    hourly_visibility = hourly.Variables(8).ValuesAsNumpy()  # Visibility\n    hourly_wind_speed_10m = hourly.Variables(9).ValuesAsNumpy()  # Wind speed at 10m\n    hourly_wind_direction_10m = hourly.Variables(10).ValuesAsNumpy()  # Wind direction at 10m\n    \n    # Create a time range for the hourly data using Pandas (supports hourly intervals)\n    start_time = datetime.fromtimestamp(hourly.Time(), tz = timezone.utc)  # Start time of the data\n    end_time = datetime.fromtimestamp(hourly.TimeEnd(), tz = timezone.utc)  # End time of the data\n    interval = pd.Timedelta(seconds=hourly.Interval())  # Time interval between data points\n    \n    # Generate the date range using Pandas\n    date_range = pd.date_range(\n        start = start_time,\n        end = end_time - interval,  # Subtract interval to match the API's inclusive=\"left\" behavior\n        freq = interval\n    )\n    \n    # Create a dictionary to store the hourly weather data\n    hourly_data = {\n        \"date\": date_range,\n        \"temperature_2m\": hourly_temperature_2m,\n        \"precipitation_probability\": hourly_precipitation_probability,\n        \"precipitation\": hourly_precipitation,\n        \"rain\": hourly_rain,\n        \"showers\": hourly_showers,\n        \"snowfall\": hourly_snowfall,\n        \"snow_depth\": hourly_snow_depth,\n        \"weather_code\": hourly_weather_code,\n        \"visibility\": hourly_visibility,\n        \"wind_speed_10m\": hourly_wind_speed_10m,\n        \"wind_direction_10m\": hourly_wind_direction_10m\n    }\n    \n    # Convert the dictionary to a Polars DataFrame and return it\n    return pl.DataFrame(hourly_data)\n\n\n\n\n\nWrite hourly api results.dbWriteTable(\nduckdb_con, \n\"hourly_day_forecast\", \ndata.frame(py$import_api_hourly(38.748, -90.439)),\noverwrite = TRUE\n)\n\nCoordinates 38.74498748779297¬∞N -90.4433364868164¬∞E\nElevation 175.0 m asl\nTimezone b'America/Chicago' b'GMT-6'\nTimezone difference to GMT+0 -21600 s\n\n\n\n\n\nRun the API script to import the dataset.import openmeteo_requests\n\nimport requests_cache\nimport pandas as pd\nfrom retry_requests import retry\n\ndef import_api_hourly_historical(latitude: float, longitude: float) -&gt; pd.DataFrame:\n     \n     # Setup the Open-Meteo API client with cache and retry on error\n     cache_session = requests_cache.CachedSession('.cache', expire_after = -1)\n     retry_session = retry(cache_session, retries = 5, backoff_factor = 0.2)\n     openmeteo = openmeteo_requests.Client(session = retry_session)\n     \n     # Make sure all required weather variables are listed here\n     # The order of variables in hourly or daily is important to assign them correctly below\n     url = \"https://archive-api.open-meteo.com/v1/archive\"\n     params = {\n        \"latitude\": 38.748,\n        \"longitude\": -90.439,\n        \"start_date\": \"1980-01-01\",\n        \"end_date\": \"2024-12-31\",\n        \"hourly\": [\n             \"temperature_2m\", \n             \"precipitation\", \n             \"rain\", \n             \"snowfall\", \n             \"snow_depth\", \n             \"visibility\",\n             \"weather_code\", \n             \"wind_speed_10m\", \n             \"wind_direction_10m\"],\n        \"temperature_unit\": \"fahrenheit\",\n        \"wind_speed_unit\": \"mph\",\n        \"precipitation_unit\": \"inch\",\n        \"timezone\": \"America/Chicago\",\n        \"models\": \"best_match\"\n     }\n     responses = openmeteo.weather_api(url, params=params)\n     \n     # Process first location. Add a for-loop for multiple locations or weather models\n     response = responses[0]\n     print(f\"Coordinates {response.Latitude()}¬∞N {response.Longitude()}¬∞E\")\n     print(f\"Elevation {response.Elevation()} m asl\")\n     print(f\"Timezone {response.Timezone()} {response.TimezoneAbbreviation()}\")\n     print(f\"Timezone difference to GMT+0 {response.UtcOffsetSeconds()} s\")\n     \n     # Process hourly data. The order of variables needs to be the same as requested.\n     hourly = response.Hourly()\n     hourly_temperature_2m = hourly.Variables(0).ValuesAsNumpy()\n     hourly_precipitation = hourly.Variables(1).ValuesAsNumpy()\n     hourly_rain = hourly.Variables(2).ValuesAsNumpy()\n     hourly_snowfall = hourly.Variables(3).ValuesAsNumpy()\n     hourly_snow_depth = hourly.Variables(4).ValuesAsNumpy()\n     hourly_visibility = hourly.Variables(5).ValuesAsNumpy()\n     hourly_weather_code = hourly.Variables(6).ValuesAsNumpy()\n     hourly_wind_speed_10m = hourly.Variables(7).ValuesAsNumpy()\n     hourly_wind_direction_10m = hourly.Variables(8).ValuesAsNumpy()\n\n     hourly_data = {\"date\": pd.date_range(\n        start = pd.to_datetime(hourly.Time(), unit = \"s\", utc = True),\n        end = pd.to_datetime(hourly.TimeEnd(), unit = \"s\", utc = True),\n        freq = pd.Timedelta(seconds = hourly.Interval()),\n        inclusive = \"left\"\n     )}\n     \n     hourly_data[\"temperature_2m\"] = hourly_temperature_2m\n     hourly_data[\"precipitation\"] = hourly_precipitation\n     hourly_data[\"rain\"] = hourly_rain\n     hourly_data[\"snowfall\"] = hourly_snowfall\n     hourly_data[\"snow_depth\"] = hourly_snow_depth\n     hourly_data[\"visibility\"] = hourly_visibility\n     hourly_data[\"weather_code\"] = hourly_weather_code\n     hourly_data[\"wind_speed_10m\"] = hourly_wind_speed_10m\n     hourly_data[\"wind_direction_10m\"] = hourly_wind_direction_10m\n     \n     hourly_dataframe = pd.DataFrame(data = hourly_data)\n     \n     return(hourly_dataframe)\n\n\n\n\n\nWrite hourly api historical data.dbWriteTable(\nduckdb_con, \n\"hourly_historical_weather\",\npy$import_api_hourly_historical(38.748, -90.439),\noverwrite = TRUE\n)\n\nCoordinates 38.769771575927734¬∞N -90.49114990234375¬∞E\nElevation 175.0 m asl\nTimezone b'America/Chicago' b'GMT-6'\nTimezone difference to GMT+0 -21600 s\n\n\n\nRealistic Coordinate Examples\n\n\nIntersection of Hwy 70 & 270\n\n38.748, -90.439\n\n\n\nThe St.¬†Louis Regional Freightway\n\n38.627480, -90.189781\n\n\n\nPort of St.¬†Louis\n\n38.609215, -90.204275\n\n\n\nUSPS Office Kansas City International Airport\n\n\nKC, MO\n\n39.304413, -94.720711\n\n\n\n\n\nWalmart Distribution Center\n\n\n1100 Matlock Dr, Saint James, MO 65559-9026\n\n38.002338, -91.634422\n\n\n\n\n\nKCS International Freight Gateway\n\n\n3301 East 147th Street, Kansas City, MO 64147\n\n38.84930037041913, -94.55499143307868\n\n\n\n\nEnum\n\n\nload enum file#' Create ENUM Type and Associate Codes with Descriptions\n#'\n#' This function creates an ENUM type in DuckDB and associates codes with their descriptions.\n#' It can be used to create other ENUM types and associations\n#'\n#' @param duckdb_conn A DuckDB connection object.\n#' @param enum_name A string specifying the name of the ENUM type to be created.\n#' @param codes A character vector of codes to be included in the ENUM type.\n#' @param descriptions A character vector of descriptions corresponding to the codes.\n#' @example\n#' \\dontrun{\n#' library(DBI)\n#' \n#' codes &lt;- c('0', '1', '2', '3', '45', '48', '51', '53', '55', '56', '57', \n#'            '61', '63', '65', '66', '67', '71', '73', '75', '77', '80', '81', \n#'            '82', '85', '86', '95', '96', '99')\n#' descriptions &lt;- c('Clear sky', 'Mainly clear', 'Partly cloudy', 'Overcast', \n#'                   'Fog', 'Depositing rime fog', 'Drizzle: Light', 'Drizzle: Moderate', \n#'                   'Drizzle: Dense', 'Freezing Drizzle: Light', 'Freezing Drizzle: Dense', \n#'                   'Rain: Slight', 'Rain: Moderate', 'Rain: Heavy', 'Freezing Rain: Light', \n#'                   'Freezing Rain: Heavy', 'Snow fall: Slight', 'Snow fall: Moderate', \n#'                   'Snow fall: Heavy', 'Snow grains', 'Rain showers: Slight', \n#'                   'Rain showers: Moderate', 'Rain showers: Violent', 'Snow showers: Slight', \n#'                   'Snow showers: Heavy', 'Thunderstorm: Slight or moderate', \n#'                   'Thunderstorm with slight hail', 'Thunderstorm with heavy hail')\n#' \n#' result &lt;- create_enum_and_associate(duckdb_con, \"WeatherCode\", codes, descriptions)\n#' print(result)\n#' }\n#' @export\ncreate_enum_and_associate &lt;- function(duckdb_con, enum_name, codes, descriptions) {\n     \n     # Attempt to drop the ENUM type if it exists\n     drop_query &lt;- paste0(\"DROP TYPE IF EXISTS \", enum_name, \";\")\n     \n     tryCatch({\n          dbExecute(duckdb_con, drop_query)\n          message(paste(\"Dropped existing ENUM type:\", enum_name))\n     }, error = \\(e) {\n          message(paste0(\"No existing ENUM type to drop: \", enum_name))\n     })\n     \n     # Create the ENUM type\n     enum_query &lt;- paste0(\"CREATE TYPE \", enum_name, \" AS ENUM (\", \n                          paste0(\"'\", codes, \"'\", collapse = \", \"), \");\")\n     dbExecute(duckdb_con, enum_query)\n     message(paste0(\"Created ENUM type: \", enum_name))\n     \n     # Write an association table for reference\n     dbWriteTable(\n          duckdb_con,\n          \"WeatherCode\",\n          data.frame(\n               Code = codes,\n               Description = descriptions,\n               stringsAsFactors = TRUE\n          ),\n          overwrite = TRUE\n     )\n}\n\n\n\n\n\nSets the custom data types in the database.codes &lt;- c(\n'0',\n'1',\n'2',\n'3',\n'45',\n'48',\n'51',\n'53',\n'55',\n'56',\n'57',\n'61',\n'63',\n'65',\n'66',\n'67',\n'71',\n'73',\n'75',\n'77',\n'80',\n'81',\n'82',\n'85',\n'86',\n'95',\n'96',\n'99'\n)\n\ndescriptions &lt;- c(\n'Clear sky',\n'Mainly clear',\n'Partly cloudy',\n'Overcast',\n'Fog',\n'Depositing rime fog',\n'Drizzle: light',\n'Drizzle: moderate',\n'Drizzle: dense',\n'Freezing drizzle: light',\n'Freezing drizzle: dense',\n'Rain: slight',\n'Rain: moderate',\n'Rain: heavy',\n'Freezing rain: light',\n'Freezing rain: heavy',\n'Snow fall: slight',\n'Snow fall: moderate',\n'Snow fall: heavy',\n'Snow grains',\n'Rain showers: slight',\n'Rain showers: moderate',\n'Rain showers: violent',\n'Snow showers: slight',\n'Snow showers: heavy',\n'Thunderstorm: slight or moderate',\n'Thunderstorm with slight hail',\n'Thunderstorm with heavy hail'\n)\n\ncreate_enum_and_associate(duckdb_con, \"WeatherCode\", codes, descriptions)\n\nDropped existing ENUM type: WeatherCode\n\n\nCreated ENUM type: WeatherCode\n\n\n\n\n\ntable setuprTable &lt;- tbl(duckdb_con, \"WeatherCode\") |&gt; collect()\n\nlocations_list = colnames(rTable)\n\nnotes_list =  list(\n\"World Meteorlogical Organization (WMO) code.\", \n\"Type of meterological event.\")\n\nfootnotes_df &lt;- tibble(\n  notes = notes_list, \n  locations = locations_list)\n\npal_df &lt;- tibble(\n  cols = locations_list,\n  pals = list(eval_palette(\"basetheme::brutal\", 7, 'd', 1))\n)\n\nrTable &lt;- r_table_theming(\nrTable,\ntitle = \"Weather Code: As Data Type\",\nsubtitle = NULL,\nfootnotes_df,\nsource_note = md(\"**source**: World Meteorlogical Organization\"),\npal_df,\nmultiline_feet = TRUE,\ntbl_font_size = pct(85),\ntarget_everything = TRUE,\ncolor_by_columns = \"Code\",\n#doBodyShadows = FALSE\n#row_name_col = \"Model\"\n)\n\n\n\n(‚ÄúWMO CODE TABLE 4677‚Äù 2025)\n\n‚ÄúWMO CODE TABLE 4677.‚Äù 2025. https://www.nodc.noaa.gov/archive/arc0021/0002199/1.1/data/0-data/HTML/WMO-CODE/WMO4677.HTM.\n\n\n\n\n\nTable¬†1: How the WMO codes are associated to weather events.\n\n\n\n\n\n\n\nWeather Code: As Data Type\n    \n\nCode1\n\n      Description2\n\n    \n\n\n\n0\nClear sky\n\n\n1\nMainly clear\n\n\n2\nPartly cloudy\n\n\n3\nOvercast\n\n\n45\nFog\n\n\n48\nDepositing rime fog\n\n\n51\nDrizzle: light\n\n\n53\nDrizzle: moderate\n\n\n55\nDrizzle: dense\n\n\n56\nFreezing drizzle: light\n\n\n57\nFreezing drizzle: dense\n\n\n61\nRain: slight\n\n\n63\nRain: moderate\n\n\n65\nRain: heavy\n\n\n66\nFreezing rain: light\n\n\n67\nFreezing rain: heavy\n\n\n71\nSnow fall: slight\n\n\n73\nSnow fall: moderate\n\n\n75\nSnow fall: heavy\n\n\n77\nSnow grains\n\n\n80\nRain showers: slight\n\n\n81\nRain showers: moderate\n\n\n82\nRain showers: violent\n\n\n85\nSnow showers: slight\n\n\n86\nSnow showers: heavy\n\n\n95\nThunderstorm: slight or moderate\n\n\n96\nThunderstorm with slight hail\n\n\n99\nThunderstorm with heavy hail\n\n\n\nsource: World Meteorlogical Organization\n    \n\n\n\n1 World Meteorlogical Organization (WMO) code.\n    \n\n\n2 Type of meterological event."
  },
  {
    "objectID": "index.html#weather-condition-analysis",
    "href": "index.html#weather-condition-analysis",
    "title": "Weather Assistant",
    "section": "Weather Condition Analysis",
    "text": "Weather Condition Analysis\nFROM to Table\n\n\ntable setupr_df &lt;- tbl(\nduckdb_con, \"hourly_historical_weather\") |&gt;\ndplyr::select(!'visibility') |&gt;\ndplyr::slice_sample(n = 20) |&gt;\ndplyr::collect() |&gt;\ndplyr::mutate(\ndate = as.character.POSIXt(date),\ndate = forcats::as_factor(date)\n)\n\nlocations_list = colnames(r_df)\n\nnotes_list &lt;- c(\n  \"Date and time in POSIXt.\",\n  \"Temperature at 2 meters above the ground in Fahrenheit.\",\n  \"Total precipitation in inches.\",\n  \"Rain precipitation in inches.\",\n  \"Snowfall in inches.\",\n  \"Snow depth in inches.\",\n  #\"Visibility in miles.\",\n  \"Weather code indicating the current weather condition.\",\n  \"Wind speed at 10 meters above the ground in miles per hour.\",\n  \"Wind direction at 10 meters above the ground in degrees.\"\n)\n\nfootnotes_df &lt;- tibble(\n  notes = notes_list, \n  locations = locations_list\n)\n\npal_df &lt;- tibble(\n  cols = locations_list,\n  pals = list(eval_palette(\"grDevices::Greens 3\", , 'c', -1))\n)\n\nrTable &lt;- r_table_theming(\nr_df,\ntitle = \"Historical View\",\nsubtitle = NULL,\nfootnotes_df,\nsource_note = md(\"**source**: \"),\npal_df,\nmultiline_feet = TRUE,\ntbl_font_size = pct(80),\ndoBodyShadows = TRUE\n)\n\n\n\n\n\n\n\nTable¬†4\n\n\n\n\n\n\n\nHistorical View\n    \n\ndate1\n\n      temperature_2m2\n\n      precipitation3\n\n      rain4\n\n      snowfall5\n\n      snow_depth6\n\n      weather_code7\n\n      wind_speed_10m8\n\n      wind_direction_10m9\n\n    \n\n\n\n1988-08-02 01:00:00\n89.75660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n0\n5.110945\n156.80139\n\n\n1998-09-29 12:00:00\n68.33660\n0.007874016\n0.007874016\n0.00000000\n0.00000000\n51\n4.718956\n185.44025\n\n\n1990-06-12 02:00:00\n73.28660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n0\n6.187236\n167.47121\n\n\n1980-07-30\n87.05659\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n0\n5.368800\n360.00000\n\n\n2017-03-11 18:00:00\n33.56600\n0.003937008\n0.000000000\n0.02755906\n0.03280840\n71\n4.273782\n47.12111\n\n\n1981-01-23 16:00:00\n37.55660\n0.000000000\n0.000000000\n0.00000000\n0.03280840\n3\n3.641572\n317.48959\n\n\n1997-08-16 08:00:00\n81.29660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n0\n11.126686\n210.17343\n\n\n1986-11-09 17:00:00\n44.48660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n0\n9.127947\n323.97253\n\n\n1983-04-12 17:00:00\n60.14660\n0.007874016\n0.007874016\n0.00000000\n0.00000000\n51\n14.416072\n138.14505\n\n\n2011-07-18 11:00:00\n76.61660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n1\n6.171040\n223.53127\n\n\n2023-04-06\n51.20600\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n3\n6.579215\n305.31128\n\n\n2023-11-09\n73.16600\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n1\n6.843904\n281.30991\n\n\n2023-11-14 21:00:00\n62.00600\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n0\n8.108932\n155.55606\n\n\n1980-10-24 21:00:00\n47.81660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n3\n13.608978\n295.30136\n\n\n2008-04-20 10:00:00\n45.56660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n0\n3.421952\n281.30991\n\n\n1991-01-21 11:00:00\n12.62660\n0.000000000\n0.000000000\n0.00000000\n0.03280840\n3\n12.125282\n307.50421\n\n\n1995-05-21 04:00:00\n63.83660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n3\n5.222329\n260.13425\n\n\n2017-03-14 18:00:00\n30.05600\n0.003937008\n0.000000000\n0.02755906\n0.06561679\n71\n10.746917\n357.61411\n\n\n2005-05-30 14:00:00\n70.22660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n1\n3.641572\n42.51040\n\n\n2016-12-30\n40.70660\n0.000000000\n0.000000000\n0.00000000\n0.00000000\n0\n15.907887\n295.84433\n\n\n\nsource:\n    \n\n\n\n1 Date and time in POSIXt.\n    \n\n\n2 Temperature at 2 meters above the ground in Fahrenheit.\n    \n\n\n3 Total precipitation in inches.\n    \n\n\n4 Rain precipitation in inches.\n    \n\n\n5 Snowfall in inches.\n    \n\n\n6 Snow depth in inches.\n    \n\n\n7 Weather code indicating the current weather condition.\n    \n\n\n8 Wind speed at 10 meters above the ground in miles per hour.\n    \n\n\n9 Wind direction at 10 meters above the ground in degrees.\n    \n\n\n\n\n\n\n\n\n\nGGplot Testing\n\n\n\n\n\n\n\n\n\n\n(a) Weather Codes\n\n\n\n\n\n\n\n\n\n\n\n(b) Freezing/Non-Freezing Temperature\n\n\n\n\n\n\n\n\n\n\n\n(c) Visibility (km)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Visibility Categories\n\n\n\n\n\n\n\n\n\n\n\n(e) Precipitation (empty if no precipitation)\n\n\n\n\n\n\n\n\n\n\n\n(f) Wind Rose\n\n\n\n\n\n\n\nFigure¬†1: These are the grouped figures.\n\n\nFigure¬†1\nFigure¬†1 (a)\nFigure¬†1 (b)\nFigure¬†1 (c)\nFigure¬†1 (d)\nFigure¬†1 (e)\nFigure¬†1 (f)"
  }
]